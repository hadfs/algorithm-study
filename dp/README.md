## 背包问题的种类

背包问题是动态规划的常见题型，按物品可选次数、结构与约束可分为以下几类（括号内给出常见转移与循环方向要点）：

- 0-1 背包：每件物品最多选一次。
  - 一维压缩：`for w = C..weight` 递减，`f[w] = max(f[w], f[w-weight] + value)`。
  - 二维写法：`f[i][w] = max(f[i-1][w], f[i-1][w-weight]+value)`。

- 完全背包：每件物品可无限次选取。
  - 一维压缩：`for w = weight..C` 递增，`f[w] = max(f[w], f[w-weight] + value)`。
  - 与 0-1 背包唯一区别在于容量循环方向（升序/降序）。

- 多重背包（有数目上限）：每件物品最多可选 `s` 次。
  - 朴素枚举次数：在 0-1 的基础上枚举 0..s 次，复杂度较高。
  - 二进制拆分：将 `s` 按 1,2,4,... 拆分为若干 0-1 物品（总件数约 O(log s)），转化为 0-1 背包。
  - 单调队列优化：按容量模 `weight` 分组，对每组做滑动窗口最大值优化，适用于大 `s`、大容量场景。

- 分组背包：物品分组，每组最多选一件。
  - 转移：对每组进行一次 0-1 合并，`for w = C..0`，组内遍历所有候选：`f[w] = max(f[w], f[w-weight_j] + value_j)`。

- 混合背包：同一题中既有 0-1、完全、也有多重物品。
  - 按物品类型分别采用对应的容量循环策略或转化（如多重用二进制拆分），逐件（或逐组）合并。

- 二维/多维背包：容量是向量（如重量与体积双约束）。
  - 状态 `f[c1][c2]`（或更多维），转移需双/多重容量循环递减，复杂度随维数指数增长，常配合剪枝或启发式。

- 树形（依赖）背包：物品存在先决依赖关系（常为树/森林）。
  - DFS 子树，做“子树规模 × 容量”的 knapsack 合并；若有“选根才能选子”的约束，先处理根再逐子合并。

- 目标变体与可行性：
  - 最小费用达到至少/恰好价值：交换“容量/价值”的角色或将 `f` 定义为最小费用，转移取 `min`。
  - 方案计数/可行性判断：布尔/计数 DP，转移用逻辑或加法；可在 0-1/完全的循环规则上替换运算。

常用模板小结：

```cpp
// 0-1 背包（1D）
for (auto [wt, val] : items) {
  for (int w = C; w >= wt; --w)
    f[w] = max(f[w], f[w - wt] + val);
}

// 完全背包（1D）
for (auto [wt, val] : items) {
  for (int w = wt; w <= C; ++w)
    f[w] = max(f[w], f[w - wt] + val);
}

// 多重背包（二进制拆分 -> 0-1 背包）
vector<pair<int,int>> split;
for (auto [wt, val, s] : items) {
  for (int k = 1; s > 0; k <<= 1) {
    int use = min(k, s);
    split.push_back({use * wt, use * val});
    s -= use;
  }
}
for (auto [wt, val] : split) {
  for (int w = C; w >= wt; --w)
    f[w] = max(f[w], f[w - wt] + val);
}
```

实战中优先判断题目属于哪一类（或组合），据此选择正确的容量循环方向/转化方式，并考虑是否需要分组、依赖、或多维约束等结构化处理。
